# Рекомендательная система для Steam.

Рекомендательные системы - одно из перспективных направлений в ML. Подобные решения улучшают разные сервисы, предоставляющие контент: система предлагает пользователю контент, который лучше всего ему подойдет. Согласитесь, что очень приятно при поиске чего-то получать быстро именно то, что нравится :)
Существует множество методов и готовых библиотек (LightFM, Implicit, решения от Microsoft и т.д.) для формирования рекомендательных систем. Условно их можно разделить на системы опирающеся на взаимодействия и связи пользователя и контента и системы опирающиеся на тип контента. 

В качестве датасета используются данные, скачанные с сайта www.kaggle.com.
В открытом доступе имеются данные о сервисе Steam.
Датасет выглядит следующим образом:
<h1 align="center"> <img width="650" alt="Снимок экрана 2023-03-06 в 22 57 23" src="https://user-images.githubusercontent.com/25271759/223217785-10eaae36-3dfd-42e3-bb94-4ec3abd01add.png"> </h1>

*(unknown - не используется и был удален)*

Для работы с данными требуется сформировать датасет, в котором будут отражены следующие данные: userId, gameId (присваиваем в соответствии с названием игры), rating.
Если Id пользователя и игры определить достаточно просто, то для столбец оценки (rating) требуется сфорировать. Выстраивать рейтинговую систему игр будем на основе времени потраченном пользователем на игру (duration). Данные о покупке игры мы не берем в расчет.
Для этого воспользуемся кластеризацией (предварительно определив оптимальное количество кластеров и нормализовав столбец duration).
<h1 align="center"> <img width="450" alt="Снимок экрана 2023-03-06 в 23 35 15" src="https://user-images.githubusercontent.com/25271759/223224808-25a923c3-ac57-48f8-80ff-f19de620db9c.png"> </h1>

Итоговый вид обработанного датасета:
<h1 align="center"> <img width="450" alt="Снимок экрана 2023-03-07 в 00 10 52" src="https://user-images.githubusercontent.com/25271759/223231668-0e779009-dda3-421d-a087-6ef029301a46.png"> </h1>

*столбец cluster приравнивается к rating (оценке)*

*в обучение модели участвуют столбцы userId, gameId, cluster*

Исходя из данных в датасете сделать рекомендательную систему на основе контента не представляется возможным (как минимум нет информации о жанре игры). Чаще всего в подобных случаях используют коллаборативную фильтрацию, в основе которой лежит матрица факторизации. 
Данный проект выполнен в качестве учебного с целью изучения построения рекомендательной системы на основе нейронной коллаборативной фильтрации.

Нейронная Коллаборативная Фильтрация (Neural Collaborative Filtering - далее NCF) - это обобщенная структура для выполнения коллаборативной фильтрации фильтрации в рекомендательных системах с использованием глубоких нейронных сетей (Deep Neural Network - далее DNN). В NCF используется нелинейность, комплексность, а также возможность давать оптимизированные результаты DNN, для лучшего понимания сложных взаимодействий пользователя и элемента (в нашем случае конкретной игры).

Общий вид NCF:

<h1 align="center"> <img width="650" src="https://user-images.githubusercontent.com/25271759/223230687-4c3235fe-dafe-4689-a052-a26880d10418.png"> </h1>

1) Входной уровень: начальный уровень архитектуры NCF принимает разреженные элементы с горячим кодированием и пользовательские векторы как $v^{U}_u$ и $v^{I}_i$. Это очень эффективно решает проблему холодного запуска любой рекомендательной системы, поскольку используемые здесь входные векторы разрежены.

2) Встраиваемый слой: используется, чтобы сделать разреженные слои плотными, полноссвязанный слой работает как встраиваемый слой. Сгенерированные элементы и пользовательские плотные векторы можно рассматривать, как векторы скрытых признаков, которые вводятся в глубокий слой NCF.

3) NCF слой: исходя из базового понимания нейронных сетей, мы понимаем, что каждый слой из слоев NCF может быть настроен для обнаружения определенных скрытых структур взаимодействия пользователя с элементом. 

4) Выходной слой: последний выходной слой состоит из предсказания целевого значения, т. е. $y^{u}_i$ в качестве метки 1 означает, что элемент i имеет отношение к u, а 0 — в противном случае. 
